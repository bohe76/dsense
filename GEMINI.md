# Gemini Added Memories
## 도구 사용 가이드라인 및 컨펌 원칙

#### **핵심 기본 원칙**
- **모든 도구 실행**은 사용자님의 **명시적인 컨펌을 통해서만** 이루어진다.
- 어떠한 작업도 사용자님의 컨펌 없이 자동으로 실행하지 않는다.
- 다만, 사용자가 특정 지시에 대해 **예외적으로 승인 없이 계속 하라는 지시**를 받으면 그 지시에 따라 **승인 없이 계속해서 코드 작성**을 한다.

#### 컨펌 요청 방식
- 컨펌 요청 시, 실행할 도구 호출(tool call) 코드 블록을 먼저 제시한다.
- 사용자님의 `진행` 또는 `y` 컨펌을 받은 후에만 해당 도구 호출을 실행한다.
- `진행` 또는 `y` 컨펌은 직전에 제시된 단일 도구 호출에만 유효하며, 다음 단계의 도구 호출은 새로운 컨펌을 필요로 한다.
- 사용자님의 `대기해` 지시가 있거나 컨펌을 기다리는 동안에는 어떠한 도구도 자동으로 실행하지 않는다.

#### **코드 및 문서 파일 수정 컨펌 절차:** 
`docs/nextjs_tasks.md`와 같은 문서 파일 또는 `src/components/Button.tsx`와 같은 코드 파일 수정 시에는 다음 2단계 컨펌 절차를 따른다.
1. 수정될 내용(텍스트) 또는 코드 변경 사항을 요약해서 제시만하고 대기한다. (도구 호출 코드 블록 없이). 사용자님의 컨펌이 있으면 다음 단계를 실행한다.
2. 사용자님의 해당 내용에 대한 승인을 받으면, 해당 내용을 적용할 도구 호출(tool call) 코드 블록을 제시하고, **사용자님의 명시적인 컨펌이 있을 때까지 어떠한 추가 출력도 생성하지 않고 완전히 대기한다.**
3. 사용자님의 도구 호출에 대한 명시적인 컨펌이 있으면 작업을 실행한다.

#### 지시어 처리
- 사용자님의 '변경', '수정', '추가' 같은 코드와 관련된 지시어는 사용자의 지시에 맞게 즉시 실행한다.
- 사용자님의 '설명', '제안', '대기' 같은 코드와 관련되지 않는 지시어는 도구 호출을 실행하지 않고 지시에 맞게 설명 또는 제안 후 대기한다.

### Git 커밋 작업 원칙

#### 커밋 제안
- **커밋 제안**은 사용자님이 **명시적으로 요청하지 않는 이상 절대 제안하지 않는다.**

#### 커밋 메시지 생성
- 커밋 메시지는 제목과 본문을 포함하여 한글로 생성한다.
- 커밋 메시지 유형은 Conventional Commits 규칙을 따른다. 예: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`, `perf`, `ci`, `build`, `revert`, `env`, `deps`

#### 커밋 메시지 작성
  - 복잡하거나 여러 줄로 구성된 커밋 메시지 작성 시, 임시 파일을 활용한다.
  - 파일 생성: `write_file` 도구를 사용하여 프로젝트 루트 디렉토리(예: `commit_message.txt`)에 커밋 메시지 내용을 담은 임시 파일을 생성한다.
  - 커밋 실행: `git commit -F commit_message.txt` 명령어를 `run_shell_command` 도구를 통해 실행한다.
  - 파일 삭제: 커밋 완료 후, `rm commit_message.txt` 명령어를 `run_shell_command` 도구를 통해 실행하여 임시 파일을 삭제한다.
  - **커밋 메시지 전달**: `git commit` 명령어 사용 시, 인터랙티브 편집기(`Vim` 등)가 실행되는 것을 방지하기 위해 `-m` 플래그로 커밋 메시지를 항상 명시적으로 전달해야 한다. 예: `git commit -m "커밋 메시지"`

#### Git 변경 사항 검토 및 명령 출력 절차
  - 기본 명령인 `git diff`로 시도를 먼저 하고, 터미널에서 멈출 경우 아래의 방법으로 한다.
  - 변경 사항 검토 및 Git 명령 출력 확인 시, 터미널 페이저(`less`, `more` 등)로 인해 명령창이 멈출 수 있는 **모든 Git 명령(예: `git diff`, `git log`)에 `--no-pager` 옵션을 사용**하여 페이저 없이 내용을 확인한다.
  - "많은 내용을 출력하는 `git diff` 명령으로 인해 터미널 문제가 발생할 경우, 출력을 임시 파일로 리디렉션한 후 (예: `git diff --staged > temp_diff.txt`), `read_file` 도구로 해당 파일을 읽어 내용을 확인해야 합니다. (필요시 `limit`/`offset` 사용). 확인 후 임시 파일을 삭제해야 합니다. 이 방법은 터미널 멈춤 현상을 방지하고 효율적인 검토를 가능하게 합니다."

#### Git 실행 절차
- 사용자님의 해당 메시지에 대한 명시적인 승인을 받으면, 커밋을 수행할 도구 호출(tool call) 코드 블록을 제시하고 실행한다.
- 커밋이 완료되면 다음 지시를 위해 대기한다.

#### Git 브랜치 관리
- 브랜치 생성, 전환, 삭제 등 모든 브랜치 관련 작업은 사용자님의 명시적인 지시 후에만 수행된다. **절대로 사용자님의 지시 없이 브랜치를 삭제하지 않는다.**

### Shell 명령어 (run_shell_command) 사용 원칙

- **명령어 연결 (`&&`):** `run_shell_command`는 `&&`와 같은 셸 명령어 연결자를 완벽하게 지원하지 않을 수 있다. 여러 명령어를 실행해야 할 경우, 각 명령어를 개별적으로 실행하는 것을 권장한다.
- **npm 스크립트 실행 (Windows PowerShell):** PowerShell 환경에서 `npm` 스크립트 실행 시 권한 오류가 발생할 수 있다. 이를 피하기 위해 `cmd /c "npm [스크립트명]"` 형식으로 명령어를 실행하는 것을 권장한다. 예: `cmd /c "npm run dev"`

### 실행 검증 절차

#### 3단계 절차
1. 사용자에게 무엇을 어떻게 테스트해야 하는지 구체적인 검증 계획을 먼저 제시한다.
2. 사용자의 동의를 얻으면 앱을 실행한다.
3. 실행 후 즉시 다음 지시를 위해 대기한다.

### 서버 실행 관리

- `uvicorn`과 같은 서버 실행 명령은 사용자님의 명시적인 지시가 없는 한, 이미 실행 중인 것으로 판단하고 자동으로 재실행하지 않는다. 개발 서버 실행 시에는 항상 백그라운드 실행을 고려하고, 관련 명령어를 안내한다.

---

### 개발 원칙 (코드 관련)

#### 개발 방식
- 각 단계별로 테스트를 먼저 작성한 후 구현을 진행하는 TDD(Test-Driven Development) 방식으로 개발한다.

#### 설계 및 구조 원칙
- SOLID 원칙을 준수하며 코드를 작성한다.
- Clean Architecture의 계층 간 의존성 방향을 준수한다.

#### 예외 대응 및 안정성 설계
- 예외 대응 및 안정성 설계 원칙을 준수한다.
- 방어적 프로그래밍(Defensive Programming)을 통해 외부 입력, API 응답, DB 결과 등 예측 불가능한 상황에 대비한다.
- Fail-Fast 원칙을 적용하여 시스템 상태 이상이나 인증 실패 등 치명적인 오류는 즉시 감지하고 중단한다.
- 사전 조건 검증(Precondition Checking)을 통해 함수나 API 호출 전에 필수 파라미터 및 상태값을 확인한다.
- API는 멱등성(Idempotency)을 고려하여 설계하며, 동일한 요청이 반복되더라도 시스템 상태가 변하지 않도록 한다.
- 시스템은 일부 기능 실패 시에도 핵심 기능이 유지되도록 우아한 실패 처리(Graceful Degradation)를 적용한다.

#### 코드 작성 원칙
- 중복된 로직을 최소화하고, 재사용 가능한 구조로 작성하는 DRY(Don’t Repeat Yourself) 원칙을 준수한다.
- 코드는 단순하고 명확하게 작성하며, KISS(Keep It Simple, Stupid) 원칙을 통해 가독성과 유지보수성을 높인다.

---

### TDD 원칙

#### Python TDD 원칙
- `pytest` 또는 `unittest`를 사용하여, 함수나 클래스가 반환해야 할 결과값, 예외 처리, 상태 변화 등 핵심 동작에 대한 테스트 코드를 먼저 작성한다.
- 테스트는 사용자의 요구사항이나 기능 명세를 기반으로, 입력값과 기대 결과를 명확히 정의한다.
- 테스트가 실패하면(Red), 해당 테스트를 통과시키기 위한 최소한의 기능 구현(Green)을 진행한다.
- 테스트가 통과된 후에는 코드의 가독성, 재사용성, 성능 등을 고려하여 리팩토링을 수행한다.
- 리팩토링 후에도 모든 테스트가 통과되어야 하며, 테스트는 기능 변경 시 자동 검증 수단으로 작동해야 한다.
- 테스트는 단순히 통과 여부를 확인하는 것이 아니라, 코드의 안정성과 유지보수성을 높이는 핵심 도구로 간주한다.

#### Next.js(React) TDD 원칙
- `Jest`와 `React Testing Library(RTL)`를 사용하여, 컴포넌트가 사용자에게 보여줘야 할 결과물(텍스트, 버튼 등)과 사용자의 상호작용(클릭, 입력)에 대한 테스트를 먼저 작성한다.
- 테스트는 기능 명세나 사용자 요구사항을 기반으로, 입력 조건과 기대 결과를 명확히 정의한다.
- 테스트가 실패하면(Red), 해당 테스트를 통과시키기 위한 최소한의 UI 컴포넌트를 구현한다.
- 테스트가 통과된 후에는 코드 구조 개선 및 최적화를 위한 리팩토링을 진행한다.
- 리팩토링 후에도 모든 테스트가 통과되어야 하며, 테스트는 기능 변경 시 자동 검증 수단으로 작동해야 한다.
- 테스트는 단순히 통과 여부를 확인하는 것이 아니라, 코드의 안정성과 유지보수성을 높이는 핵심 도구로 간주한다.

### 디버깅 및 검증 도구

#### 1. 로컬 서버 백그라운드 실행 (PowerShell)
Python의 `http.server` 모듈을 사용하여 로컬 정적 파일 서버를 백그라운드에서 실행할 수 있습니다. 이는 `run_shell_command` 도구를 통해 실행됩니다.

```powershell
Start-Process python -ArgumentList "-m", "http.server", "8080" -NoNewWindow
```
*   포트 번호(예: 8080)는 필요에 따라 변경 가능합니다.
*   서버 실행 후 `chrome-devtools-mcp` 도구로 접속하여 테스트할 수 있습니다.

#### 2. Chrome DevTools MCP 사용법
브라우저를 직접 제어하고 콘솔 로그를 확인하거나 DOM을 조작하여 실시간 디버깅을 수행할 수 있습니다.

*   `navigate_page`: 특정 URL로 브라우저를 이동시킵니다. (예: `http://localhost:8080`)
*   `take_snapshot`: 현재 페이지의 DOM 구조와 요소별 UID를 스냅샷으로 캡처합니다. 요소를 찾을 때 필수입니다.
*   `click`: UID를 사용하여 요소를 클릭합니다.
*   `fill`: UID를 사용하여 입력 필드에 값을 채웁니다.
*   `evaluate_script`: 페이지 내에서 JavaScript 코드를 실행합니다.
*   `list_console_messages`: 브라우저 콘솔에 출력된 로그를 가져옵니다. 디버깅 로그(`console.log`) 확인 시 유용합니다.

### DSENSE 프로젝트 특이사항 (Preferences)

#### 디자인 및 인터랙션 취향
- **고급스러운 유체 효과 선호:** Hero 섹션 등 주요 비주얼에 WebGL 기반의 유체 시뮬레이션(Fluid/Smoke) 또는 파티클 효과를 선호함.
- **섬세한 표현:** 굵고 투박한 잉크보다는 **가늘고 섬세한 붓 터치** 느낌의 인터랙션을 지향함. (예: 시뮬레이션 해상도 High, Radius Low)
- **Time-based HSL 순환:** 단색보다는 시간 흐름에 따라 색상이 은은하게 변하는(Hue Cycle) 효과를 좋아함.

#### 자산 관리 및 백업 전략
- **배포 제외 백업:** 프로젝트에서 더 이상 사용하지 않지만 보관이 필요한 에셋(예: 교체된 이미지)은 `public` 폴더가 아닌 프로젝트 루트의 **`_assets_backup`** 폴더로 이동시켜 배포 패키지 용량을 최적화한다.

#### 필터 UI/UX 구현 방식
- **Select Mode + ALL 칩:** 필터는 "차감" 방식이 아닌 "선택" 방식. 기본 ALL 활성화, 특정 카테고리 클릭 시 ALL 비활성화.
- **우선순위 정렬:** 마지막에 클릭한 카테고리가 먼저 표시됨 (배열 사용, `unshift`).
- **스크롤 모션 블러:** 필터 오토 스크롤 시에만 SVG feGaussianBlur 블러 효과 적용 (Lenis velocity 연동).